<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <!-- blank favicon -->
    <link href="data:image/x-icon;base64,iVBORw0KGgo=" rel="icon" type="image/x-icon" />
    <title>AR demo</title>

    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <!--
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    -->

    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>

    <style>
        body 
        { 
            margin: 0; 
            overflow: hidden; 
        }
    </style>

</head>
<body>

<script>
  AFRAME.registerComponent('axes-helper', {
      schema: { size: {type: 'number', default: 1} },
      init: function () {
        const helper = new THREE.AxesHelper(this.data.size);
        this.el.object3D.add(helper);
      }
    });

    /*
function getWorldPose(obj3D)
{
    const pos = new THREE.Vector3();
    const quat = new THREE.Quaternion();
    obj3D.updateMatrixWorld(true);
    obj3D.getWorldPosition(pos);
    obj3D.getWorldQuaternion(quat);

    const xAxis = new THREE.Vector3(1, 0, 0).applyQuaternion(quat).normalize(); // world direction of marker's +X
    const yAxis = new THREE.Vector3(0, 1, 0).applyQuaternion(quat).normalize(); // world direction of marker's +Y
    const zAxis = new THREE.Vector3(0, 0, -1).applyQuaternion(quat).normalize(); // world direction of marker's +Z

    return { pos, quat, xAxis, yAxis, zAxis };
}
*/

function averageWithoutOutliers(vecs, epsilon) 
{
  const THREE = AFRAME?.THREE || window.THREE;
  if (!vecs || vecs.length === 0) throw new Error("No vectors");

  //console.log("calculating average of " + vecs.length)
  if (vecs.length == 1) 
  {
      // console.log("only one")
      return vecs[0].clone();
  }

  // Compute provisional mean
  const mean = new THREE.Vector3();
  vecs.forEach(v => mean.add(v));
  mean.multiplyScalar(1 / vecs.length);

  // Keep only inliers within epsilon distance of the mean
  const inliers = vecs.filter(v => v.distanceTo(mean) <= epsilon);

  // status report
  // if (vecs.length > inliers.length)
  //   console.log("outliers rejected! " + Math.random())

  // If all were rejected, just return the initial mean
  if (inliers.length === 0) return mean;

  // Recompute mean from inliers
  const result = new THREE.Vector3();
  inliers.forEach(v => result.add(v));
  result.multiplyScalar(1 / inliers.length);

  return result;
}

AFRAME.registerComponent('marker-handler', 
{
   init: function()
   {
        this.markerArray = document.querySelectorAll("a-marker");
        this.sphereArray = document.querySelectorAll("a-sphere");
        this.oMarkerArray = document.querySelectorAll("[o-marker]")
        this.xMarkerArray = document.querySelectorAll("[x-marker]")
        this.yMarkerArray = document.querySelectorAll("[y-marker]")
        this.zMarkerArray = document.querySelectorAll("[z-marker]")
        
        this.visibleIdArray = [];
   },

   tick: function() 
   {
        this.visibleIdArray = [];

        let oMarkerVisibleArray = [];
        let xMarkerVisibleArray = [];
        let yMarkerVisibleArray = [];
        let zMarkerVisibleArray = [];
        
        for (let i = 0; i < this.markerArray.length; i++)
        {
            const marker = this.markerArray[i];
            const plane  = marker.querySelector('a-plane');
            if (marker.object3D.visible)
            {
                this.visibleIdArray.push(i);
                plane.setAttribute('color', '#00ff00');

                oMarkerVisibleArray.push( this.oMarkerArray[i] );
                xMarkerVisibleArray.push( this.xMarkerArray[i] );
                yMarkerVisibleArray.push( this.yMarkerArray[i] );
                zMarkerVisibleArray.push( this.zMarkerArray[i] );

                // const pos = new THREE.Vector3();
                // marker.object3D.getWorldPosition(pos);
                // console.log("marker " + i + " visible")
            }
            else
            {
                plane.setAttribute('color', '#ff0000');
                // console.log("marker " + i + " NOT visible")
            }
        }
        //console.log( this.markerArray.length )
        //console.log( this.visibleIdArray )

        if (this.visibleIdArray.length == 0)
            return;

        //console.log("markers found " + this.visibleIdArray.length)



        //const originSphere = document.querySelector("#origin")
        //position = calculatePosition(oMarkerVisibleArray)
        document.querySelector("#origin").object3D.position.copy( calculatePosition(oMarkerVisibleArray) );

        //const xAxisSphere = document.querySelector("#xAxis")
        //position = calculatePosition(xMarkerVisibleArray)
        document.querySelector("#xAxis").object3D.position.copy( calculatePosition(xMarkerVisibleArray) )
        document.querySelector("#yAxis").object3D.position.copy( calculatePosition(yMarkerVisibleArray) )
        document.querySelector("#zAxis").object3D.position.copy( calculatePosition(zMarkerVisibleArray) )

   }
});

// assume everything passed to this array is visible
function calculatePosition(elementArray)
{
    let positionArray = [];
    // get positions for all visible markers
    for (let i = 0; i < elementArray.length; i++)
    {
        const element = elementArray[i];
        const pos = new THREE.Vector3();
        element.object3D.getWorldPosition(pos);
        positionArray.push(pos)
    }
    //console.log( "position vectors: " + positionArray.length)
    return averageWithoutOutliers(positionArray, 0.5)
}

</script>

<a-scene embedded
    vr-mode-ui="enabled: false"
    arjs="detectionMode: mono_and_matrix; matrixCodeType: 3x3; "
    renderer="logarithmicDepthBuffer: true;">

    <a-entity camera>
        <a-entity light="type: ambient; color: #888"></a-entity>
        <a-entity light="type: directional; color: #FFF; intensity: 1.8" position="-0.5 1 1"></a-entity>
    </a-entity> 

    
    <a-entity marker-handler></a-entity>
    <a-sphere id="origin" radius="0.1" color="gray"></a-sphere>
    <a-sphere id="xAxis"  radius="0.1" color="red"></a-sphere>
    <a-sphere id="yAxis"  radius="0.1" color="green"></a-sphere>
    <a-sphere id="zAxis"  radius="0.1" color="blue"></a-sphere>

</a-scene>


<script>


// since ID 0-3 are the front face of the cube, and we want the planes to lie flat, 
//   they need to be rotated -90 degrees around x in general.
//   y-axis is perpendicular to face / center of cube
let y = 0.0
const markerData = [
    {id: 0, pos: new THREE.Vector3(-1.50, y, +1.50), rot:{x:0, y:0, z:0}},
    {id: 1, pos: new THREE.Vector3(+0.00, y, +1.50), rot:{x:0, y:0, z:0}},
    {id: 2, pos: new THREE.Vector3(+1.50, y, +1.50), rot:{x:0, y:0, z:0}},
    {id: 3, pos: new THREE.Vector3(-1.50, y, +0.00), rot:{x:0, y:0, z:0}},
    {id: 4, pos: new THREE.Vector3(+0.00, y, +0.00), rot:{x:0, y:0, z:0}}, // rememb: align to original axes
    {id: 5, pos: new THREE.Vector3(+1.50, y, +0.00), rot:{x:0, y:0, z:0}},
    {id: 6, pos: new THREE.Vector3(-1.50, y, -1.50), rot:{x:0, y:0, z:0}},
    {id: 7, pos: new THREE.Vector3(+0.00, y, -1.50), rot:{x:0, y:0, z:0}},
    {id: 8, pos: new THREE.Vector3(+1.50, y, -1.50), rot:{x:0, y:0, z:0}},
]

const scene = document.querySelector("a-scene");

function createBarcodeMarker(data) 
{
    const marker = document.createElement('a-marker');
    marker.setAttribute('type', 'barcode');
    marker.setAttribute('value', String(data.id));
    marker.setAttribute('id', `marker${data.id}`);
    marker.setAttribute('smooth', "false");
    
    marker.data = data;

    const plane = document.createElement('a-plane');
    plane.setAttribute('color', '#0000ff');
    plane.setAttribute('opacity', 0.4);
    plane.setAttribute('rotation', '-90 0 0');
    plane.setAttribute('position', '0 0.001 0');
    plane.setAttribute('material', 'side: double;');
    marker.appendChild(plane);

    // numeric label (marker ID), centered on the square
    const label = document.createElement('a-entity');
    label.setAttribute('text', `value: _${data.id}_; align:center; side:double; color: navy; width: 8.0;`);
    label.setAttribute('position', '0 0 0.01');
    //label.setAttribute('material', 'side: double;');
    plane.appendChild(label);

    const sphere = document.createElement('a-sphere');
    sphere.setAttribute('radius', '0.1');
    sphere.setAttribute('id', `sphere${data.id}`);
    scene.appendChild(sphere)

    // use to track center of associated cube volume
    const axes = document.createElement('a-entity');   
    // TODO: fix (claims elements are visible, but they are not) -- maybe only parent vis switches. bubbles down to children in scene graph
    axes.setAttribute('axes-helper', '');
    axes.setAttribute('o-marker', '');
    axes.setAttribute('position', `${-data.pos.x} ${data.pos.y} ${data.pos.z}`);
    axes.setAttribute('rotation', `${data.rot.x} ${data.rot.y} ${data.rot.z}`);
    
    marker.appendChild(axes);

    // empty coordinate for tracking axis directions
    const xMarker = document.createElement('a-entity');
    xMarker.setAttribute('x-marker', '');
    xMarker.setAttribute('position', `1 0 0`);
    axes.appendChild(xMarker)

    const yMarker = document.createElement('a-entity');
    yMarker.setAttribute('y-marker', '');
    yMarker.setAttribute('position', `0 1 0`);
    axes.appendChild(yMarker)

    const zMarker = document.createElement('a-entity');
    zMarker.setAttribute('z-marker', '');
    zMarker.setAttribute('position', `0 0 1`);
    axes.appendChild(zMarker)

    marker.addEventListener('markerFound',  () => {
        console.log('Marker found:', data.id);
        // your code here (show UI, start audio, etc.)
    });

    marker.addEventListener('markerLost', () => {
        console.log('Marker lost:', data.id);
        // your code here (hide UI, stop audio, etc.)
    });

    return marker;
}


for (let i = 0; i < markerData.length; i++)
    scene.appendChild( createBarcodeMarker( markerData[i] ) );


</script>

</body>
</html>



